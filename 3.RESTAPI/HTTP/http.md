## HTTP

HTTP, the hypertext transfer protocol. Any time you interact with content on the web, you use the HTTP protocol to send requests and receive responses between servers and browsers and the HTTP protocol defines how all this information is formatted and transmitted. HTTP facilitates every transaction we make over the World Wide Web. Click on a link and the browser sends a request to get the data from server. Click on the submit button on a social media post and the browser sends a request to post the data you just typed in to a database on the server. The web is the biggest and most accessible information resource ever made and HTTP is the reason it works so well we rarely consider what's going on behind the scenes. Knowing how HTTP works and how to work with it, gives you the power to make the web work for you.

## What is HTTP?

- HTTP is an acronym for Hypertext Transfer Protocol, literally a protocol used to transfer hypertext. Which begs two questions. What is a protocol and what is hypertext? In this context, a protocol is a system of rules that allow communication of information between different entities, like computers. Hypertext is a somewhat outdated word for text that is displayed on a computer screen that contains hyperlinks to other text. So web documents. So, the hypertext transfer protocol is the set of rules, servers and browsers used to transfer web documents back and forth. Which is why every URL you type into a web browser starts with http. That's a nice definition, but it doesn't tell us much about the nature of HTTP. What it is.

- So let's dig in a bit deeper. One of the core principles of HTTP is that is plain language and human readable. When you see an HTTP request, response or message, you can read it out loud and make sense of it even if you don't necessarily know how the technology works. As an example, all HTTP request methods use simple human language verbs. Get, post, put, delete and so on. You don't need to know anything about computers or computer networks to get what I mean. Another principle is that HTTP is a stateless protocol. That means each individual request sent over the protocol is unique, and no request is connected to another request. To put it in another way, HTTP has no memory of previous requests. Go to a web page with a photo gallery, and it will show you the first picture. Go reload your browser or type in the URL again and you get the first picture again, because HTTP has no memory of you making that first request. This statelessness ensures users don't get trapped in or placed in the middle of sequences of content, but it also means they can't walk their way through sequences because the requests are not connected.

- To fix this, HTTP allows sessions. Stored states shared between the browser and the server. If a visitor is flipping their way through a photo gallery, the browser and server can exchange information about where the visitor is in the sequence by passing information back and forth in the form of cookies. Reload the page, and the browser sends along a cookie to the server saying, "Hey, last time we spoke "we were looking at the third picture, start there."

- This means, while HTTP is stateless, it is not sessionless. That passing of cookies that allows HTTP to preserve sessions is made possible by the extensibility of HTTP. When requests and responses are sent back and forth over HTTP, we can include HTTP headers with additional information. These headers can carry information about everything from what type of client sent the requests, the server configuration and the time and date of the response to how and for how long the client should store the data, what format the data is in, those cookies used to track sessions and so on. Which brings us to the last basic principle. HTTP works based on request/response pairs. Every action performed over HTTP starts with a request using one of the HTTP methods and ends with a response containing an HTTP status code saying what happened to the request along with the data like headers and content.

## HTTP1, HTTP2, HTTPS

- Quick sidebar, when people talk about HTTP, they often refer to HTTPS and HTTP/2, and it's important to know what these things are right off the top. Just like every other web technology, the HTTP protocol is constantly evolving and new features are added to make it work better, faster, and with new technologies. When I talk about HTTP in this course, I'll be referring to version two of the protocol, simply called HTTP/2. HTTP/2 is relatively new in web terms, and as of right now, powers between 70 and 80 percent of all transactions over the web. The older protocol, HTTP/1.1, is still very much alive, and it's also the fallback protocol anytime HTTP/2 fails, which means you will encounter HTTP/1.1 from time to time now, and in the future. So, what's the difference between HTTP/2 and HTTP/1.1? the most important points are HTTP/2 is faster and more secure. It uses compression algorithms to speed up requests, allows for multi-plexing, meaning multiple files are sent over connection at the same time and requires an encrypted connection between the client and the server through HTTPS. By contrast, HTTP/1 sends uncompressed headers, transfers only one file at a time over a connection, and has no default encryption. What does all this mean? Well, in an ideal world, every HTTP transaction would be done over an encrypted HTTPS connection using the HTTP/2 protocol. In the real world, it means most HTTP transactions will use HTTPS over HTTP/2, and when that doesn't work, they'll fall back on unencrypted HTTP/1.1, which, while slower, still works just as well.

## HTTP terms

- Browser
  The browser is an application used to access and navigate between HTML documents, nothing more, nothing less. Browsers come in many varieties, the most common being the regular visual browsers you see on your smartphone or tablet or computer. Other browsers include text-to-speech audio browsers, text-only browsers, VR, AR, MR, XR browsers, et cetera, et cetera.

- User Agent

  A user agent is an application that is acting on behalf of the user, so a literal user agent. It is also commonly referred to as a client application. When we talk about HTTP, the user agent in question is whatever application is transporting information from the user to a server and back. That job typically falls to the browser, but it's not limited to the browser. It can also be middleware or a service like Google or even a server. Пользовательский агент — это приложение, которое действует от имени пользователя, то есть буквальный пользовательский агент. Его также часто называют клиентским приложением. Когда мы говорим о HTTP, рассматриваемый пользовательский агент — это любое приложение, передающее информацию от пользователя на сервер и обратно. Эта работа обычно ложится на браузер, но она не ограничивается браузером. Это также может быть промежуточное ПО или служба, такая как Google, или даже сервер.

- TCP
  TCP is short for Transmission Control Protocol. It is one of the main internet protocols used by, among other things, the World Wide Web, email, FTPs, a file transfer protocol, and remote administration. When you connect to a service over the internet, you are probably using a TCP connection.
  TCP-ն ինտերնետի հիմնական protocol-ներից մեկն է։ Երբ դու կապվում ես ծառայությանը ինտեռնետի միջոցով, հավանաբար դու օգտագործում ես TCP conection.

- IP
  IP is short for Internet Protocol, the protocol used to actually transfer data between computers over a network. Each computer connected to the internet has a dedicated IP address which is used to connect to it. IP-ն կարճ է Internet Protocol-ի համար, protocol, որն օգտագործվում է իրականում տվյալների փոխանցման համար համակարգիչների միջև ինտերնետի միջոցով: Ինտերնետին միացված յուրաքանչյուր համակարգիչ ունի հատուկ IP հասցե, որն օգտագործվում է ինտերնետին միանալու համար:

  - URL
    The URL is quite literally a Universal Resource Locator, a universally understood address pointing at a resource somewhere on the web. URLs are human-readable addresses stored in Domain Name Servers and configured to point to the IP addresses of web servers. When you type in a web address in the address bar of your browser, that address is automatically prefixed with either HTTP or HTTPS, telling you you are using the Hypertext Transfer Protocol to access the resource at the other end of that universal locator.

- Server

  A server is a computer on the internet running some form of data storage and sharing application, most commonly a web server application, allowing users to access its data through the HTTP protocol. HTTP is a client server protocol, meaning the clients, or user agent, most commonly the browser, sends request to the server and the server serves responses back to the client.

- Proxy

A proxy is a service, either software or hardware, acting as a middle person between clients and servers. Proxies are often used when the IP address of a server needs to be hidden or when a server or client sits behind some sort of network barrier like a firewall. The proxy is quite literally a proxy handing data back and forth.

- Request Response

Clients and servers communicate over HTTP using request-response pairs. Whenever a client, typically a browser, talks to a server, it does so by sending an HTTP request. That request contains a request method describing what action is requested, an address pointing to a resource, and other information about the client. If the client is trying to send information to the server, that information is also packaged in the request as a payload. The response is the literal response to the request. It contains a status response code explaining what happened, information about how the response was handled, and any data requested if the response was successful.

- Header

Requests and responses use HTTP headers to identify themselves and explain what they want. Every request and response has a header and some also have payloads, the data that's transferred. The header contains metadata about the request facilitating communication between clients and servers.
the HTTP protocol is stateless, meaning it doesn't store any information between requests. This means, if a client, or the server, or both, need information about the state of the other, or any other information, we have to send that information along with our request or response. That's what HTTP headers are for

-method/verbs

The headers of an HTTP request always contain a request method, or verb. These methods are words like get to get something, put to put something, update to update something, delete to delete something, et cetera.

- status code

  The header of an HTTP response always contains a status response code. These are numerical codes in the 100 to 500 range describing what type of response the client is receiving, 200 OK, 404 Not Found, 500 Server Error, et cetera.

- cache

  Web servers and clients can cache, so literally store data for a specified length of time to speed up transfers and performance. As an example, when you visit a regular we0bsite, your browser will likely download the CSS for that website once and then cache it in its memory so when you navigate to the next page or come back to the site later, you don't have to re-download that CSS file. Websites and web servers can instruct clients to cache files, clear cached files, or update specific cached files. All this is done through instructions passed in a cache header.

- stateless

  HTTP is a stateless protocol, meaning there is no link between two requests being sent between the client and the server. When we need to create a stateful session, we can use cookies, small pieces of information passed back and forth between the client and the server in the HTTP header to notify each party of the state the other is in. This, for example, is how once you've logged into a service, you typically stayed logged in. The server has placed a cookie in your browser in its cache and when you visit the site the next time, that cookie is sent back to the server saying, hey, we've already met and you trust me, so just let me in.

## The HTTP flow

TO get a clear idea of how HTTP works, imagine the whole web as a library and you are a client looking for information. In this library, each cubby in a shelf is a website. A site can carry a bunch of different information, documents, images, video and audio, style sheets, JavaScript files, et cetera. When you want to see what's in one of these websites, you go to a librarian and make a hypertext transfer protocol request. Can I get the stuff in cubby number four? This request is received and handled by the librarian representing servers on the web who goes to the cubby, gathers up the relevant pieces to match your request, and hands them back with a response status.

1. This is the flow of all HTTP transactions. First, the browser opens a TCP connection to the server. This ensures data can be sent back and forth over the network and that the data sent from one end is put together the same way at the other end. If the connection happens over HTTPS, TLS certificates are exchanged to ensure only the computer and the server can encrypt and decrypt the transmitted data. This prevents anyone from being able to eavesdrop on the conversation between the client and the server and steal the data they are transmitting.
2. Second, the browser sends an HTTP message. This message always contains an HTTP method, like GET, PUT, DELETE or something similar, and a URL pointing at the requested resource. It can also contain headers like cookies or authentication data and data if the browser is submitting data to the server using the post, put, or path methods.
3. Third, the server performs the requested actions and sends a response back to the browser. This response will contain an HTTP status message indicating what happened, headers with information about the response, and whatever data was requested. This data could be an HTML document or a style sheet or a JavaScript file or image or any other type of content used in a standard website.
4. Finally, once the response is fully received, the TCP connection is closed. Since HTTP is stateless, we are now back to a clean slate. In most scenarios, the first HTTP transaction between a browser and a server is to retrieve a web document for a page or a view. This document typically holds links to CSS and JavaScript files as well as referenced elements like images. Each of these items is fetched from their server and brought into the browser using the same HTTP flow. HTTP/2 allows multiplexing, meaning multiple transactions can take place over the same TCP connection at the the same time. This new protocol also allows the server to push data to the browser, meaning if the browser requests a specific document, the server can say, "hey, this document depends "on these other files, so I'll push them "to you at the same time." All of this improves performance and reduces the load time for webpages and views significantly.

## URL

- To get access to information on the web you need to know the address of that information. That's what the URL or universal resource locator is for. A URL is a human-readable address, describing exactly where on the web and in what location on a server the information you are requesting is located. Let's take a regular URL and break it apart to see how it fits together, https://linkedin.com/learning/ javascript-essential-training-3/ and then a bunch of extra information.
  The URL has two main pieces, a protocol declaration, and a Universal Resource Name, or URN. This URN provides the location of the resource. The protocol declaration states how we are accessing that resource using the http methods and transport layer. The URN itself is made up of several pieces.
  First, we have the host. This is the domain which is registered at a domain name service, or DNS. And this domain points to a dedicated server IP address, somewhere on the web. Next, we have the implied, and usually invisible, connection port, stating which port we want to access on the server. For http connections, the default port is 80. For https connections, the default port is 443. As long as the server uses either of these ports, we don't see the port declared. If the server uses another port or we want to access another port, say 8080, that port can be declared using a colon, localhost:8080. After the host and port comes the resource path. This is the file location within the server. The default names for web documents are index.html and default.html, or just htm, or something like that.

  If we request a folder without a file specification, the server and browser automatically look for files named either index.html or default.html or index.php or similar and returns that file to us.
  If the file is called anything else, like about.html or contact.php, etc., the resource path needs to list the filename specifically, so mysite.com/folder/about.html.

  Finally, we have the optional URL query. This is one or more queries added to the end of the resource path that can perform further actions on the server. In some cases, such queries are used to track a user's ID, in others they're used to filter content or perform other actions. URL queries start with a question mark and then each query comprises an argument and a value like u=1234. These queries can be strung together, using the ampersand symbol.

## HTTP methods

Selecting transcript lines in this section will navigate to timestamp in the video

- Every request sent over the HTTP protocol includes a method, aka a verb. This method tells the server what type of action we want to perform with the request. There are a limited set of these methods available and some are more used than others. For standard web transactions, we typically only use three. GET, POST, and DELETE. But these are not the only methods available to use. Each of the HTTP methods has it's own request response pair and some require more information than others to work. Let's take a closer look.
- GET
  By far the most frequently used HTTP method is GET. It is also the simplest one. A GET request for a public resource only needs the method and the URL to work. If this resource sits behind a security layer, the request typically also needs an authorization header containing an encrypted username and password pair and may require a cookie containing an authentication token. If a GET request is successful, a 200 OK HTTP status is returned along with the requested data. If it fails, meaning the requested resource does not work, the familiar 404 Not Found status is returned telling you the resource quite literally cannot be found at this address. If the user does not have the correct access authorization, a 405 Not Allowed status is returned and if the resource is blocked by the server, a 403 Forbidden status is returned.
  To send data from the client to the server, we have three different methods to perform different types of actions. POST, PUT, and PATCH.

- POST

  POST is the most common of these methods, as it is the one useD when you submit a form on a webpage. A POST request asks the server to create a new resource and give it an ID for future retrieval. Because POST requests make changes to the server, they typically need an authorization header. A successful POST request returns a 201 Created HTTP status along with a link to the new resource ID and the response header. If the resource already exists, the server returns a 409 Conflict status and if the resource is sent to a resource that can't create new resources then you get a 404 Not Found HTTP status in return.

- PUT

PUT is used to update an existing resource by replacing some or all of its contents with the contents of the request. Like POST, PUT typically requires an authorization header. Unlike POST, which just contains the contents, a PUT request contains the ID of a resource and the new content to be added to that resource. If the resource already exists, the existing content is replaced with the contents in the PUT request. If no resource with this ID exists, the server will in some cases allow the new resource to be created with the user defined ID or you'll get an error message. A successful PUT request returns a 200 OK status. If there is no content on the server, a 204 No Content status is returned. If the ID doesn't match an existing resource, a 404 Not Found status is returned. If a PUT request is sent to a resource that can't be updated, a 405 Method Not Allowed status is returned.

- PATCH

PATCH is used to modify an existing resource. Where PUT updates the resource by replacing content, Patch can carry along instructions on how to modify the existing resource without necessarily replacing data. PATCH also typically requires an authorization header and returns the same status as PUT.

-DELETE

DELETE does exactly what it sounds like. It deletes a specified resource. A DELETE request must contain the ID for the resource and an authorization header. If you try to delete a resource you are not allowed to delete, you'll get a 405 Method Not Allowed status. What actually happens on the server when you send a DELETE request varies from server to server. In some cases you delete a database entry. In other cases, you change the status of a database entry without actually removing content. It all depends on the design of the system you're interacting with. In addition to these content methods, HTTP also has three methods to get information from the server without really touching the content. They are HEAD, which returns just the HEAD section of the response, OPTIONS which returns a description of the communication options for the target resource, and TRACE, which creates a loop back of the request message effectively telling the client where the request ended up.

## Cookies

To get an idea of how headers are used to perform actions by both servers and browsers, let's look at two examples. First up, cookies. As I've explained before, cookies are used to pass states between clients and servers over the stateless HTTP protocol, effectively setting up sessions between the server and client. Let's say I have a website with a login panel and once someone has logged in, I want their browser to remember that and authenticate itself by telling the server who it is and that it's already in a logged in state. This can be done using a cookie. When the user first goes to the site, they are met with a login panel. They put in their username and password and the site lets them in. At this point, the server includes a set cookie response header with a unique token or string of characters in its response and also stores that same string in its own database associated with the current logged in user. The browser receives this cookie and keeps it in its memory.

These cookies are for authentication purposes and also provide other information. all of these cookies are sent along in my request header and these cookies help identify who I am. If I go back to the headers, you can actually see that. If I click on raw headers here. In the request header, here, you'll see under the cookie header, we have all that same information passed on to the server. Now, the next time a request is sent from the browser to the server, the request header includes a cookie header with the same unique tokens. The server receives the request, checks the token in the cookie against its own database and if everything matches, sends back the data as requested. Cookies can be used for everything from keeping people logged in to making sure they land back where they left off to tracking their behavior. Because cookies are often used by advertisers to track users across multiple websites, many companies and the European Union, have made it mandatory for any site that uses cookies to explicitly warn the end user that cookies are being used to track them. That's why you see all these cookie warnings on sites you visit. Now you know it has nothing to do with actual cookies.

## Caching

The second example is caching. On your website, you may have contents that are rarely updated, like your JavaScript or CSS files, content that is sometimes updated, like pages, and content that is updated all the time, like the front page or news section of an information site. Both servers and clients can tell the other party to cache, literally store for later, any files they send through HTTP. Once cached, these files will be used instead of downloading fresh ones, and this dramatically speeds up the site and the performance. You can provide specific instructions on how long to cache the files for and under what circumstances the cached files can be overwritten. All of this is done using the cache control header and various directives. These directives include max-age, no-cache, no-store, public, private and more. Most commonly Cache-Control is used to store files in the browser to speed up future visits to the same address by storing the files and then just using the stored files instead of downloading new ones. This is done using the Cache-Control: max-age directive. In this example the server says, please store this file without checking with me and use it instead of coming to me to download a fresh copy for one year. That would be 31 million, 536 thousand seconds. The browser will now hold onto the file for up to a year unless the user actively goes in and clears the cache for the browser. If a file is cached like this, the server won't be able to force the browser to update the file for one year. Meaning, any updates will not be seen by the visitor. This is why when you update a CSS or JavaScript file on a server, you sometimes can't see the new version in the browser and you have to keep rebooting the browser and eventually clear the cache. To avoid this problem you can either, tell the browser to check if the server has a newer version of the file using no cache on individual assets or on the entire domain, or explicitly tell the browser to not cache certain files, or reduce the max-age to something shorter, like a day or 30 days. Or you can use a technique called Cache Busting, where each file has a unique file name, therefore, anytime you upload a new version of a file, you're actually uploading a new unique file name and that new unique file is stored in the visitors browser. HTTP caching deserves an entire course of its own. You can learn more about it in my course HTTP Two, Developing For Performance, and find further information on MDM and on developers.google.com.
