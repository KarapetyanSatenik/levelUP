- JavaScript is a synchronous, blocking, single threaded language.
- To make async programming possible we need the help of Libuv.

We have the V8 engine which executes JavaScript code. It comprises memory heap and call stack.

Libuv will then run the task using native async mechanisms of the operating system and if that is not possible, it will utilize its thread pool to run the task ensuring the main thread is not blocked. 
the main thread of execution always starts in the global scope so the global function is pushed onto the stack and if there is no more code to execute, global function is also popped off from stack.


Read file is an async operation that is offloaded to libue, so what happens now is that the Callback function of readFile is handed over to libue JavaScript then simply pops off the readFile method from the call stack because its job is done.

In the background the Libuv starts to read the file contents on a separate thread.
When callBack will be ready due to Event Loop it will be pushed onto call stack and will be executed.
All phases are  part of libuv, but the two microtasks however are not part of libuv.

First you should know that all user written synchronous JavaScript code takes priority over asynchronous code that the runtime would like to execute. Which means only after the call stack is empty the event Loop comes into picture.

1. Any callbacks in the micro task queues are executed: first tasks in the next queue and only then tasks in the promise queue.
2. All callbacks within the timer queue are executed
3. Callbacks in the micro task queues if present are executed after the execution of every callback in the timer queue, again first tasks in the next queue and then tasks in the promise queue.
4. All callbacks within the io queue are executed 
5. Callbacks in the micro task queues if present are executed...
6. All callbacks in the check queue are executed 
7. Callbacks in the micro task queues if present are executed after the execution of every callback in the check queue again first tasks in the next queue and only then tasks in the promise queue.

If all callbacks are executed and there is no more code to process the event Loop exits.

