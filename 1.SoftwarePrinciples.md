# Design Principles

Follow these principles, will allow you to write better code. Remember that a clean code it’s easier to main, easier to understand and for sure it will save your time when you need to change or implement something. Avoid use duplicated code, try to keep your code as simple as possible, and just implement features when it’s really necessary.

## DRY, KISS & YAGNI Principles

- Those are three principles that every developer should care, because they are about clean code. In this article we are going to understand what each one of them means.

### DRY Principle

DRY stands for Don’t Repeat Yourself. In the book ‘The Pragmatic Programmer’, we can see this definition for DRY:

Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

This means that you should not have duplicated code. It’s easier to maintain a code that is only in one place, because if you need to change something in the code, you just need to change in one place. Besides that, if you have the same code in two or more places, the chance of this code become different during the time is high, and when this happens it will become an easy way to introduce bugs in your system. Duplicated code also makes the code more complex and unnecessarily larger.

You also should not write ambiguous code. Your classes, your variables, your functions, they should have a specific name, and their name must match their responsibility. If you have a function, you should know what the function does by just reading its name, without being needed to read the code inside of it.

DRY is about the duplication of knowledge, of intent. It’s about expressing
the same thing in two different places, possibly in two totally different ways.

It means that it’s not only about copy and past code — yes, this is also included - but goes beyond that. It‘s also about having different code that does the same thing. Maybe you can have different code in two or more places, but they do the same thing in different ways, this also should be avoided.

```js
enum dayNames {
  Monday = "Monday",
  Tuesday = "Tuesday",
  Wednesday = "Wednesday",
  Thursday = "Thursday",
  Friday = "Friday",
  Saturday = "Saturday",
  Sunday = "Sunday"
}

class Day {
  name: string;
  order: number;

  constructor(name: string, order: number = 0) {
    this.name = name;
    this.order = order;
  }

  setOrder(order: number) : Day {
    this.order = order;
    return this;
  }

}

class Week {

  days: Array<Day> = new Array();

  private addDay(name: string): Day {
    const day = new Day(name);
    const index = this.days.push(day);
    day.setOrder(index)
    return day;
  }

  constructor() {
     for(let dayName in dayNames) {
       this.addDay(dayName);
     }
  }

  listDays() {
    console.log(this.days);
  }

}

const firstWeek = new Week();
firstWeek.listDays();
```

### KISS Principle

KISS is an acronym for Keep It Simple, Stupid. This principle says about to make your code simple. You should avoid unnecessary complexity. A simple code it’s easier to maintain and easier to understand.

You can apply this principle in the design and in the implementation of the code. You should eliminate duplicated code, should remove unnecessary features, don’t use unnecessary variables and methods, use names for variables and methods that makes sense and matches their responsibilities, and always when it’s possible, follow know standards of code development. You also should separate the responsibilities of your classes and the responsibilities from the layers of the project.

Sometimes you don’t need to implement something new to attend your needs, you can simply make use of the features of the programming language that you are using. For that, it’s good that you know the features of the programming language that you are working with.

If you are working in a code that it’s already implemented, and you see something that it’s not necessary or could be simpler, you should consider refactoring it.

```js
nterface Country {
  code: string;
  discountAmountPercent: number;
  taxAmountPercent: number;
  discountRegions: Array<string>;
}

class Poland implements Country {
    code: string = "pl_PL";
    discountAmountPercent: number = 15;
    taxAmountPercent: number = 23;
    discountRegions: Array<string> = [
      "masovia",
      "lubusz"
    ];
}

class Payment {

     setTax(price: any, tax: number) {
       return (price + (tax/100*price));
     }

     setDiscount(price: any, discount: number) {
       return (price - ((discount/100)*price));
     }

     pay(country: Country, region: string, amount: number, nettoPrice: number) {

       if (
         country.discountRegions.indexOf(region.toLowerCase()) != -1
         && amount > 15
       ) {
         nettoPrice = this.setDiscount(nettoPrice, country.discountAmountPercent);
       }

       const bruttoPrice = this.setTax(nettoPrice, country.taxAmountPercent);
       return (bruttoPrice*amount);
     }
}

const payment = new Payment();
console.log ( payment.pay((new Poland), 'masovia', 25, 1000) );
```

### YAGNI Principle

YAGNI stands for You Ain’t Gonna Need It. It’s a principle from software development methodology of Extreme Programming (XP). This principle says that you should not create features that it’s not really necessary.

This principle it’s similar to the KISS principle, once that both of them aim for a simpler solution. The difference between them it’s that YAGNI focus on removing unnecessary functionality and logic, and KISS focus on the complexity.

Always implement things when you actually need them, never when you just foresee that you need them.

It means that you should not implement functionality just because you think that you may need it someday, but implement it just when you really need it. Doing that you will avoid spending time with implementations that were not even necessary, and maybe will never be used.

### S.O.L.I.D

If you are familiar with Object-Oriented Programming, then you’ve probably heard about the SOLID principles.

These five software development principles are guidelines to follow when building software so that it is easier to scale and maintain. They were made popular by a software engineer, Robert C. Martin.
You see, some of these principles may look similar but they are not targeting the same goal. It is possible to satisfy one principle while violating the other, even though they are alike.

##### S  Single Responsibility
A class should have a single responsibility

If a Class has many responsibilities, it increases the possibility of bugs because making changes to one of its responsibilities, could affect the other ones without you knowing.

- Goal

This principle aims to separate behaviors so that if bugs arise as a result of your change, it won’t affect other unrelated behaviors.

##### O  Open-Closed
This principle suggests that “classes should be open for extension but closed for modification”. What is means is that if the class A is written by the developer AA, and if the developer BB wants some modification on that then developer BB should be easily do that by extending class A, but not by modifying class A.

The easy example would be the RecyclerView.Adapter class. Developers can easily extend this class and create their own custom adapter with custom behaviour without modifying the existing RecyclerView.Adapter class.

Changing the current behaviour of a Class will affect all the systems using that Class.

If you want the Class to perform more functions, the ideal approach is to add to the functions that already exist NOT change them.

- Goal

This principle aims to extend a Class’s behavior without changing the existing behavior of that Class. This is to avoid causing bugs wherever the Class is being used.

##### Liskov Substitution

If S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program.

When a child Class cannot perform the same actions as its parent Class, this can cause bugs.

If you have a Class and create another Class from it, it becomes a parent and the new Class becomes a child. The child Class should be able to do everything the parent Class can do. This process is called Inheritance.

The child Class should be able to process the same requests and deliver the same result as the parent Class or it could deliver a result that is of the same type.

If the child Class doesn’t meet these requirements, it means the child Class is changed completely and violates this principle.

- Goal

This principle aims to enforce consistency so that the parent Class or its child Class can be used in the same way without any errors.

##### I — Interface Segregation

Clients should not be forced to depend on methods that they do not use.

When a Class is required to perform actions that are not useful, it is wasteful and may produce unexpected bugs if the Class does not have the ability to perform those actions.

A Class should perform only actions that are needed to fulfil its role. Any other action should be removed completely or moved somewhere else if it might be used by another Class in the future.

- Goal

This principle aims at splitting a set of actions into smaller sets so that a Class executes ONLY the set of actions it requires.


##### D — Dependency Inversion

- High-level modules should not depend on low-level modules. Both should depend on the abstraction.

- Abstractions should not depend on details. Details should depend on abstractions.

Firstly, let’s define the terms used here more simply

High-level Module(or Class): Class that executes an action with a tool.

Low-level Module (or Class): The tool that is needed to execute the action

Abstraction: Represents an interface that connects the two Classes.

Details: How the tool works

This principle says a Class should not be fused with the tool it uses to execute an action. Rather, it should be fused to the interface that will allow the tool to connect to the Class.

It also says that both the Class and the interface should not know how the tool works. However, the tool needs to meet the specification of the interface.

Goal

This principle aims at reducing the dependency of a high-level Class on the low-level Class by introducing an interface.