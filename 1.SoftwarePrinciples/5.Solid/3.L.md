# Liskov Substitution Principle

This principle was expressed by Barbara Liskov in 1987.

“We present a way of defining the subtype relation that ensures that subtype objects preserve behavioral properties of their supertypes.” Liskov.

## Barbara Liskov

Liskov Substitution Principle (LSP) regulates the use of inheritance. It basically says that, subtypes must be substitutable for their base types. When we derive a new class from a base class, we can substitute this class with any other siblings or parents without getting any error in any point of the architecture. LSP claims that the concept of is-a in inheritance is insufficient. It should be replaced with is-substitutable-for. Square is-a rectangle, and square must be substitutable for rectangle in any part of the design.

Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. For a client knows the base class in an object hierarchy, it should be able to work seamlessly with objects of all subtypes of that object. Subtypes should not confuse clients who know how to use the topmost base class.

- Run-Time Type Information (RTTI) is a mechanism that exposes information about an object’s data type at runtime. It is a c++ concept, we will not dive into this concept, what we need to know that we also need to stay away from RTTI. We do not check types in runtime.

In the code example below, there is a rectangle class and a square class that inherits rectangle. Logically, the rectangle should abstractly enclose the square. However, when we look at the class structures, the fact that the rectangle has two different edge definitions and the square has only one edge definition. This creates a structural problem in inheritance. Since we assign the same value to both width and height, when we pass 2 different sides to the square, it has to take the last value and multiply it with itself. That’s the LSP problem.

```js
class Rectangle:
    
    def __init__(self, width:float = 0, height: float = 0) -> None:
        self._width = width
        self._height = height
    
    @property
    def width(self) -> float:
        return self._width
    
    @width.setter
    def width(self,value: float) -> None:
        self._width = value
        
    @property
    def height(self) -> float:
        return self._height
    
    @height.setter
    def height(self, value:float) -> None:
        self._height = value
        
class AreaCalculator:
    def calculate(self,rects):
        for r in rects:
            print("Area is : {}".format(r.height*r.width))
            
class Square(Rectangle):
    def get_width(self) -> float:
        return self._width
    
    def set_width(self, value:float) -> None:
        self._width = value
        self._height = value
    
    def get_height(self) -> float:
        return self._height
    
    def set_height(self, value:float) -> None:
        self._width = value
        self._height = value
    
    width = property(get_width,set_width)
    height = property(get_height,set_height)
    
sq = Square()
sq.width = 8
sq.height = 8

rect = Square()
rect.width = 2
rect.height = 3

liste = [sq,rect]
ac = AreaCalculator()
ac.calculate(liste)
#Area is : 64
#Area is : 9

```

We might reorganize the structure above like the one below. We had to change things a lot, and still not sure if it was a good solution.

```js
class Rectangle:
    
    def __init__(self, width:float, height: float) -> None:
        self._width = width
        self._height = height
    
    @property
    def width(self) -> float:
        return self._width
    
    @width.setter
    def width(self,value: float) -> None:
        self._width = value
        
    @property
    def height(self) -> float:
        return self._height
    
    @height.setter
    def height(self, value:float) -> None:
        self._height = value
        
    @property
    def area(self) -> float:
        return self.width * self.height
    
class Square(Rectangle):
    def __init__(self, side:float) -> None:
        self.__side = side
        super(Square,self).__init__(side,side)
        
    @property
    def width(self) -> float:
        return self.__side
    
    @width.setter
    def width(self,value: float) -> None:
        self.__side = value
        
    @property
    def height(self) -> float:
        return self.__side
    
    @height.setter
    def height(self, value:float) -> None:
        self.__side = value
        
r = Rectangle(width=10,height=5)
print(r.area)
#50

s = Square(side=5)
print(s.area)
#25
```