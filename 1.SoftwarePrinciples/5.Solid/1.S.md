# Single Responsibility Principle

A class should have one and only one reason to change, meaning that a class should have only one job. In this context, what is meant by responsibility is the reason for the change, the single reason to change. This actually means that a class should be so cohesive that there is no more than one reason to change. Let’s remember Dijkstra’s philosophy of separation of concern; we should focus only one aspect of the subject at a time.

When we consider the subject of single responsibility through the definition of the reason for change, it can be a little difficult to understand. Therefore, it would be nicer to consider the principle step by step, starting from the small code snippets, lines and going up to classes and modules.

## Line

Think of each line of code as a line of haiku poetry. It should be clear, understandable, and simple like life itself.


One statement on one line should do one job. In addition, as we do not want repetitions in the block, we do not want them in the lines, too.

```js
#found this on net, I didn't even understand what it was doing.
(lambda f: f(f, 1))(lambda f, n: None if n > 100 else print((not n % 3 and “fizz” or “”) + (not n % 5 and “buzz” or “”) or n) or f(f, n+1))
#It would be better to convert this line into a method.
```

## Method

Basically, we can say that there are four different types of methods: constructors, setters/getters, built-in methods, task methods.

- Constructors create objects, they should not have any other task.

- Setters/getters are highly cohesive methods. They always have one responsibility as nature.

- Built-in object methods or framework methods have clear responsibilities.

There are two types of task methods; atomic ones take care of a single step in the whole, they cannot be broken down into smaller pieces and coordinative methods perform processes, they consist of a combination of more than one atomic method. In these methods (coordinative), single responsibility is perceived as the process itself.

In terms of SRP, methods should only have one job, if there is an if-else conditional structure, it should be just one of the conditions and they should be responsible for a single calculation in case of complex calculations.

A new method must be made for every part that can be reused in the method block. Even though we will not be reusing it, if the methods get too big, it would be better to split some sections as private methods.

Practical suggestions would be as follows: number of lines must be 15 at most, number of passed parameters should be equal or less than 3, remember atomicity! Worker (atomic) methods generally takes primitive parameters, coordinative ones generally takes references.

## Class

Classes are responsible for concepts and should only have responsibilities of a single concept. The ones with low cohesion are divided into different classes to obtain more cohesive structure. In general, atomic methods and coordinative methods are in separate classes, because these classes have different roles in the structure, therefore it makes more sense to have different classes.

Software projects grow over time, it’s natural. As the project progresses, the level of complexity should be kept under control by refactoring and dividing the abstractions into sub-abtractions. Generally, when a class has more than twenty methods, it is better to stop and rethink. In the example below, the Phone class is both connecting and sending data. We split this class into two to make it functional cohesive. DataHandler handles data transfer and PhoneConnection is responsible for connections.

```js
class Phone(ABC):
    
    @abstractmethod
    def dial(self):
        pass
    
    @abstractmethod
    def hangup(self):
        pass
    
    @abstractmethod
    def send(self):
        pass
    
    @abstractmethod
    def receive(self):
        pass

class DataHandler(ABC):
    
    @abstractmethod
    def send(self):
        pass
    
    @abstractmethod
    def receive(self):
        pass

class PhoneConnection(ABC):
    
    @abstractmethod
    def dial(self):
        pass
    
    @abstractmethod
    def hangup(self):
        pass
  
```
If we start having trouble abstracting due to growth, we can go up one level. We can convert line to block, block to method, method to class, etc.

