# Open-Closed Principle

Our structure should be open for extensions, but closed for modification. If we need an addition in a structure, we should not do it by changing the software unit. The structure we set up beforehand should be such that we should be able to deal with this need by extending the software unit.

Let’s not forget that software changes. This is the law of coding nature. Therefore, when creating any unit part of a code structure, it is necessary to be aware of the parts that can change and the other parts that probably will not change. It would be nice to separate the parts that may change from the parts that will have static concept at the very beginning of the development. When you know what is going to change, you design these parts as easily replaceable. Imagine a vacuum cleaner. Replacing a bag is a very easy process. However, if you want to remove the engine, it is not that easy job. Why? Because the designer knew that bag will be replaced periodically, therefore she designed that part to be suitable for replacement. However, it is not a need for a customer to remove the engine, so it is not designed to be replaced by a customer. In addition to this, in order to keep the dependencies to be robust against the possibility of additions, we should establish couplings over abstractions.

OCP increases reusability and reduces maintenance costs. To reap these benefits, we must avoid low-cohesive structures. Dependencies should be installed with abstractions, not implementations.

The above example changes the speed of the vehicle according to the given operation command. This is not good for OCP because this method does different things according to the passed do_something. New requests, actions will require the addition of new if-else conditions. This shows that the method is not closed to change.

We can improve this by abstracting the car behavior out of the method. Let’s first create an abstract class CarDoes. This class abstractly does something.

Then we derive 2 classes from abstract class CarDoes;

CarBr breaks and CarAcc accelerates.

Now the final version of the method is independent of the behavior conditions, it is closed to changes. If we add new behaviors to the car, then we can derive new classes from the abstract class. car_behavior does not need to know that.

Finally, OCP is an ideal, almost impossible to achieve. We should always keep it conceptually alive in our minds and we should always strive to get closer to the ideal in terms of OCP while developing a project.

