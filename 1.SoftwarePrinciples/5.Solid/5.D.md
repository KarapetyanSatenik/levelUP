## Dependency Inversion Principle

It was published by Robert Martin again, Holy Uncle Bob. High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.

What makes a design bad? According to Mr. Martin, there are 3 main indicators of this. Rigidity, fragility and immobility. Your design unit is so rigid, you can not make any changes. If you change something, it will break many things in your design. The coupling of your structure is so high that you can not take it from there and use it elsewhere. Coupling is the bad guy here. Because of it, a change spreads like a wave of water.

We mentioned high and low level modules above. High level modules are abstractions about processes and executives. In this context, we can list coordinative methods and classes. Low level modules are the details of processes, like atomic / worker methods and classes. As we go down from higher to lower, we go down from coordinative to atomic modules, methods.

There is a risk that changes in lower-level modules will spill over to higher-level modules. The principle that should be and what we whant is that change must be start from top and go down. Higher-level decides the change because they run the processes. For example, when considering a computer product design, the characteristics of the transistor in a chip should not eventually change the behavior of the user on that computer, that transistor should be determined according to the behavior of the user.

Inter-module dependencies should be reversed so that they are abstracted. For this, an abstract type of each structure should be created and the dependencies of higher-level structures should be abstracted this way. By this way, we can make the changes on implementations.

Below, we have an elevator class, it has two methods, it opens and closes the door. And there is a elevator button, which activates methods of elevator by pressing.

```js
class Elevator:
    
    def open_door(self):
        print("Door opened")
        
    def close_door(self):
        print("Door closed")
        
class ElevatorButton:
    
    def __init__(self, e: Elevator) -> None:
        self.elevator = e
        self.open = False
    
    def press(self):
        if self.open:
            self.elevator.close_door()
            self.open = False
        else:
            self.elevator.open_door()
            self.open = True
            
e = Elevator()
button = ElevatorButton(e)
button.press()
button.press()
```
Here, you can notice that there is a dependency between elevator and the button. Button takes an elevator instance and directly access its methods. We will use abstract classes to overcome this dependency.

We will create a Device abstract class which has open and close functionality. Then we will create a subclass Elevator by inheriting the abstract class and override the abstract methods. Elevator implemented the interface of Device.


Abstraction of Elevator
Button has still direct dependency on elevator. So, we will apply Dependency Inversion and remove this dependency. We switch the Elevator with Device.